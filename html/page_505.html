<div id="page0" style="position:relative;width:540pt;height:648pt;background-color:white">
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:92pt;left:72pt"><b><span style="font-family:Helvetica,sans-serif;font-size:24.79pt">Chapter 20. Futures</span></b></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:125pt;left:24pt"><b><i><span style="font-family:Helvetica,sans-serif;font-size:14.346pt">Dangers and Opportunities</span></i></b></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:152pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">The best way to predict the future is to invent it.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:164pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">--</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:176pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt;color:#ff0000">&lt;author&gt;AlanKay&lt;/author&gt;</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:189pt;left:72pt"><i><span style="font-family:Times,serif;font-size:9.963pt">Uttered during a 1971 meeting at XEROX PARC</span></i></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:210pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">History is not over.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:210pt;left:163pt"><span style="font-family:Times,serif;font-size:9.963pt">Unix will continue to grow and change. The community and the tradition</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:222pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">around Unix will continue to evolve. Trying to forecast the future is a chancy business, but we can</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:234pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">perhaps anticipate it in two ways: &#xfb01;rst, by looking at how Unix has coped with design challenges in</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:246pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">the past; second, by identifying problems that are looking for solutions and opportunities waiting to</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:258pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">be exploited.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:280pt;left:72pt"><b><span style="font-family:Helvetica,sans-serif;font-size:15.94pt">Essence and Accident in Unix Tradition</span></b></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:309pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">To understand how Unix&#x2019;s design might change in the future, we can start by looking at how Unix</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:321pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">programming style has changed over time in the past.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:321pt;left:300pt"><span style="font-family:Times,serif;font-size:9.963pt">This effort leads us directly to one of the</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:333pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">challenges of understanding the Unix style &#x2014; distinguishing between accident and essence. That</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:344pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">is, recognizing traits that arise from transient technical circumstances versus those that are deeply</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:356pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">tied to the central Unix design challenge &#x2014; how to do modularity and abstraction right while also</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:368pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">keeping systems transparent and simple.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:390pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">This distinction can be dif&#xfb01;cult, because traits that arose as accidents have sometimes turned out to</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:402pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">have essential utility. Consider as an example the &#x2018;Silence is golden&#x2019; rule of Unix interface design</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:414pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">we examined in Chapter 11; it began as an adaptation to slow teletypes, but continued because</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:426pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">programs with terse output could be combined in scripts more easily.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:426pt;left:364pt"><span style="font-family:Times,serif;font-size:9.963pt">Today, in an environment</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:438pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">where having many programs running visibly through a GUI is normal, it has a third kind of utility:</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:450pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">silent programs don&#x2019;t distract or waste the user&#x2019;s attention.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:472pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">On the other hand, some traits that once seemed essential to Unix turned out to be accidents tied</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:484pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">to a particular set of cost ratios.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:484pt;left:218pt"><span style="font-family:Times,serif;font-size:9.963pt">For example, old-school Unix favored program designs (and</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:496pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">minilanguages like awk(1)) that did line-at-a-time processing of an input stream or record-at-a-time</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:508pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">processing of binary &#xfb01;les, with any context that needed to be maintained between pieces carried by</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:520pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">elaborate state-machine code. New-school Unix design, on the other hand, is generally happy with</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:532pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">the assumption that a program can read its entire input into memory and thereafter randomly access</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:581pt;left:262pt"><span style="font-family:Times,serif;font-size:9.963pt">504</span></p>
</div>
