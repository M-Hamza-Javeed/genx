<div id="page0" style="position:relative;width:540pt;height:648pt;background-color:white">
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:32pt;left:234pt"><span style="font-family:Times,serif;font-size:9.963pt">Chapter 15. Tools</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:100pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Design for transparency is not, however, suf&#xfb01;cient in itself. When you are debugging a program</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:112pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">at runtime, it&#x2019;s extremely useful to be able to examine the state of your program at runtime, set</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:124pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">breakpoints, and execute pieces of it down to the single-statement level in a controlled way. Unix has</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:136pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">a long tradition of hosting programs to help you with this. Open-source Unixes feature a powerful</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:148pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">one called</span><i><span style="font-family:Times,serif;font-size:9.963pt"> gdb</span></i><span style="font-family:Times,serif;font-size:9.963pt"> (yet another FSF project) that supports C and C++ debugging.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:170pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Perl, Python, Java, and Emacs Lisp all support standard packages or programs (included with their</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:181pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">base distributions) that allow you to set breakpoints, control execution, and do general runtime-</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:193pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">debugger things. Tcl, designed as a small language for small projects, has no such facility (though</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:205pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">it does have a trace facility that can be used to watch variables at runtime).</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:227pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Remember the Unix philosophy. Spend your time on design quality, not the low-level details, and</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:239pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">automate away everything you can &#x2014; including the detail work of runtime debugging.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:262pt;left:72pt"><b><span style="font-family:Helvetica,sans-serif;font-size:15.94pt">Pro&#xfb01;ling</span></b></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:290pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">As a general rule, 90% of the execution time of your program will be spent in 10% of its code.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:302pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Pro&#xfb01;lers are tools that help you identify the 10% of hot spots that constrain the speed of your</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:314pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">program. This is a good thing for making it faster.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:336pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">But in the Unix tradition, pro&#xfb01;lers have a far more important function. They enable you</span><i><span style="font-family:Times,serif;font-size:9.963pt"> not</span></i><span style="font-family:Times,serif;font-size:9.963pt"> to</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:348pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">optimize the other 90%! This is good, and not just because it saves you work. The</span><i><span style="font-family:Times,serif;font-size:9.963pt"> really</span></i><span style="font-family:Times,serif;font-size:9.963pt"> valuable</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:360pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">effect is that not optimizing that 90% holds down global complexity and reduces bugs.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:382pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">You may recall that we quoted Donald Knuth observing &#x201c;Premature optimization is the root of all</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:394pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">evil&#x201d; in Chapter 1, and that Rob Pike and Ken Thompson had a few pungent observations on the</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:406pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">topic as well. These were the voices of experience. Do good design. Think about what&#x2019;s</span><i><span style="font-family:Times,serif;font-size:9.963pt"> right</span></i><span style="font-family:Times,serif;font-size:9.963pt"> &#xfb01;rst.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:418pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Tune for ef&#xfb01;ciency later.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:440pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Pro&#xfb01;lers help you do this. If you get in the good habit of using them, you can get rid of the bad</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:452pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">habit of premature optimization. Pro&#xfb01;lers don&#x2019;t just change the way you work; they change how</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:464pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">you think.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:486pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Pro&#xfb01;lers for compiled languages rely on instrumenting object code, so they are even more platform-</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:497pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">dependent than compilers. On the other hand, a compiled-language pro&#xfb01;ler doesn&#x2019;t care about the</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:509pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">source language of the programs it instruments. Under Unix, the single pro&#xfb01;ler gprof(1) handles C,</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:521pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">C++, and all other compiled languages.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:581pt;left:262pt"><span style="font-family:Times,serif;font-size:9.963pt">410</span></p>
</div>
