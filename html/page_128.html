<div id="page0" style="position:relative;width:540pt;height:648pt;background-color:white">
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:32pt;left:225pt"><span style="font-family:Times,serif;font-size:9.963pt">Chapter 4. Modularity</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:100pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">There is some tension and con&#xfb02;ict between the Unix tradition of modularity and the usage patterns</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:112pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">that have developed around OO languages. Unix programmers have always tended to be a bit more</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:124pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">skeptical about OO than their counterparts elsewhere. Part of this is because of the Rule of Diversity;</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:136pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">OO has far too often been promoted as the One True Solution to the software-complexity problem.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:148pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">But there is something else behind it as well, an issue which is worth exploring as background before</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:160pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">we evaluate speci&#xfb01;c OO (object-oriented) languages in Chapter 14.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:160pt;left:353pt"><span style="font-family:Times,serif;font-size:9.963pt">It will also help throw some</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:172pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">characteristics of the Unix style of non-OO programming into sharper relief.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:193pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">We observed above that the Unix tradition of modularity is one of thin glue, a minimalist approach</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:205pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">with few layers of abstraction between the hardware and the top-level objects of a program.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:205pt;left:452pt"><span style="font-family:Times,serif;font-size:9.963pt">Part</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:217pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">of this is the in&#xfb02;uence of C. It takes serious effort to simulate true objects in C. Because that&#x2019;s so,</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:229pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">piling up abstraction layers is an exhausting thing to do.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:229pt;left:308pt"><span style="font-family:Times,serif;font-size:9.963pt">Thus, object hierarchies in C tend to be</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:241pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">relatively &#xfb02;at and transparent. Even when Unix programmers use other languages, they tend to want</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:253pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">to carry over the thin-glue/shallow-layering style that Unix models have taught them.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:275pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">OO languages make abstraction easy &#x2014; perhaps too easy. They encourage architectures with thick</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:287pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">glue and elaborate layers. This can be good when the problem domain is truly complex and demands</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:299pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">a lot of abstraction, but it can back&#xfb01;re badly if coders end up doing simple things in complex ways</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:311pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">just because they can.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:333pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">All OO languages show some tendency to suck programmers into the trap of excessive layering.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:345pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Object frameworks and object browsers are not a substitute for good design or documentation, but</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:357pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">they often get treated as one. Too many layers destroy transparency: It becomes too dif&#xfb01;cult to see</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:369pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">down through them and mentally model what the code is actually doing. The Rules of Simplicity,</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:381pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Clarity, and Transparency get violated wholesale, and the result is code full of obscure bugs and</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:393pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">continuing maintenance problems.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:415pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">This tendency is probably exacerbated because a lot of programming courses teach thick layering</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:427pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">as a way to satisfy the Rule of Representation. In this view, having lots of classes is equated with</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:439pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">embedding knowledge in your data. The problem with this is that too often, the &#x2018;smart data&#x2019; in the</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:450pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">glue layers is not actually about any natural entity in whatever the program is manipulating &#x2014; it&#x2019;s</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:462pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">just about being glue. (One sure sign of this is a proliferation of abstract subclasses or &#x2018;mixins&#x2019;.)</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:484pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Another side effect of OO abstraction is that opportunities for optimization tend to disappear. For</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:496pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">example,</span><i><span style="font-family:Times,serif;font-size:9.963pt"> a</span></i><span style="font-family:Times,serif;font-size:9.963pt"> +</span><i><span style="font-family:Times,serif;font-size:9.963pt"> a</span></i><span style="font-family:Times,serif;font-size:9.963pt"> +</span><i><span style="font-family:Times,serif;font-size:9.963pt"> a</span></i><span style="font-family:Times,serif;font-size:9.963pt"> +</span><i><span style="font-family:Times,serif;font-size:9.963pt"> a</span></i><span style="font-family:Times,serif;font-size:9.963pt"> can become</span><i><span style="font-family:Times,serif;font-size:9.963pt"> a</span></i><span style="font-family:Times,serif;font-size:9.963pt"> * 4 and even</span><i><span style="font-family:Times,serif;font-size:9.963pt"> a</span></i><span style="font-family:Times,serif;font-size:9.963pt"> &lt;&lt; 2 if a is an integer.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:496pt;left:389pt"><span style="font-family:Times,serif;font-size:9.963pt">But if one creates a</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:508pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">class with operators, there is nothing to indicate if they are commutative, distributive, or associative.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:520pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Since one isn&#x2019;t supposed to look inside the object, it&#x2019;s not possible to know which of two equivalent</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:532pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">expressions is more ef&#xfb01;cient. This isn&#x2019;t in itself a good reason to avoid using OO techniques on new</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:581pt;left:262pt"><span style="font-family:Times,serif;font-size:9.963pt">127</span></p>
</div>
