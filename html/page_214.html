<div id="page0" style="position:relative;width:540pt;height:648pt;background-color:white">
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:32pt;left:209pt"><span style="font-family:Times,serif;font-size:9.963pt">Chapter 7. Multiprogramming</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:100pt;left:108pt"><span style="font-family:Times,serif;font-size:9.963pt">The X server, able to execute literally millions of ops/second, is</span><i><span style="font-family:Times,serif;font-size:9.963pt"> not</span></i><span style="font-family:Times,serif;font-size:9.963pt"> threaded; it</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:112pt;left:108pt"><span style="font-family:Times,serif;font-size:9.963pt">uses a poll/select loop. Various efforts to make a multithreaded implementation</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:124pt;left:108pt"><span style="font-family:Times,serif;font-size:9.963pt">have come to no good result. The costs of locking and unlocking get too high for</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:136pt;left:108pt"><span style="font-family:Times,serif;font-size:9.963pt">something as performance-sensitive as graphics servers.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:148pt;left:422pt"><span style="font-family:Times,serif;font-size:9.963pt">&#x2014;</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:160pt;left:315pt"><span style="font-family:Times,serif;font-size:9.963pt;color:#ff0000">&lt;author&gt;JimGettys&lt;/author&gt;</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:181pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">This problem is fundamental, and has also been a continuing issue in the design of Unix kernels</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:193pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">for symmetric multiprocessing. As your resource-locking gets &#xfb01;ner-grained, latency due to locking</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:205pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">overhead can increase fast enough to swamp the gains from locking less core memory.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:227pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">One &#xfb01;nal dif&#xfb01;culty with threads is that threading standards still tend to be weak and underspeci&#xfb01;ed</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:239pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">as of mid-2003. Theoretically conforming libraries for Unix standards such as POSIX threads</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:251pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">(1003.1c) can nevertheless exhibit alarming differences in behavior across platforms, especially</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:263pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">with respect to signals, interactions with other IPC methods, and resource cleanup times. Windows</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:275pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">and classic MacOS have native threading models and interrupt facilities quite different from those of</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:287pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Unix and will often require considerable porting effort even for simple threading cases. The upshot</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:299pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">is that you cannot count on threaded programs to be portable.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:321pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">For more discussion and a lucid contrast with event-driven programming, see</span><i><span style="font-family:Times,serif;font-size:9.963pt"> Why Threads Are a</span></i></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:333pt;left:72pt"><i><span style="font-family:Times,serif;font-size:9.963pt">Bad Idea</span></i><span style="font-family:Times,serif;font-size:9.963pt"> [Osterhout96].</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:355pt;left:72pt"><b><span style="font-family:Helvetica,sans-serif;font-size:15.94pt">Process Partitioning at the Design Level</span></b></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:384pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Now that we have all these methods, what should we do with them?</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:406pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">The &#xfb01;rst thing to notice is that temp&#xfb01;les, the more interactive sort of master/slave process relation-</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:418pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">ship, sockets, RPC, and all other methods of bidirectional IPC are at some level equivalent &#x2014; they&#x2019;re</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:430pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">all just ways for programs to exchange data during their lifetimes.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:430pt;left:349pt"><span style="font-family:Times,serif;font-size:9.963pt">Much of what we do in a so-</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:442pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">phisticated way using sockets or shared memory we could do in a primitive way using temp&#xfb01;les as</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:454pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">mailboxes and signals for noti&#xfb01;cation. The differences are at the edges, in how programs establish</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:466pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">communication, where and when one does the marshalling and unmarshalling of messages, in what</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:478pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">sorts of buffering problems you may have, and atomicity guarantees you get on the messages (that</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:490pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">is, to what extent you can know that the result of a single send action from one side will show up as</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:501pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">a single receive event on the other).</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:523pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">We&#x2019;ve seen from the PostgreSQL study that one effective way to hold down complexity is to break</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:535pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">an application into a client/server pair. The PostgreSQL client and server communicate through an</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:581pt;left:262pt"><span style="font-family:Times,serif;font-size:9.963pt">213</span></p>
</div>
