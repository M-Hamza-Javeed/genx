<div id="page0" style="position:relative;width:540pt;height:648pt;background-color:white">
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:32pt;left:234pt"><span style="font-family:Times,serif;font-size:9.963pt">Chapter 15. Tools</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:95pt;left:72pt"><b><i><span style="font-family:Helvetica,sans-serif;font-size:13.948pt">yacc</span></i></b><b><span style="font-family:Helvetica,sans-serif;font-size:13.948pt"> and</span></b><b><i><span style="font-family:Helvetica,sans-serif;font-size:13.948pt"> lex</span></i></b></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:122pt;left:72pt"><i><span style="font-family:Times,serif;font-size:9.963pt">yacc</span></i><span style="font-family:Times,serif;font-size:9.963pt"> and</span><i><span style="font-family:Times,serif;font-size:9.963pt"> lex</span></i><span style="font-family:Times,serif;font-size:9.963pt"> are tools for generating language parsers.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:122pt;left:303pt"><span style="font-family:Times,serif;font-size:9.963pt">We observed in Chapter 8 that your &#xfb01;rst</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:134pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">minilanguage is all too likely to be an accident rather than a design. That accident is likely to have</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:146pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">a hand-coded parser that costs you far too much maintenance and debugging time &#x2014; especially if</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:158pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">you have not realized it is a parser, and have thus failed to properly separate it from the remainder</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:170pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">of your application code.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:170pt;left:184pt"><span style="font-family:Times,serif;font-size:9.963pt">Parser generators are tools for doing better than an accidental, ad-hoc</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:181pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">implementation; they don&#x2019;t just let you express your grammar speci&#xfb01;cation at a higher level, they</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:193pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">also wall off all the parser&#x2019;s implementation complexity from the rest of your code.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:215pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">If you reach a point where you are planning to implement a minilanguage from scratch, rather</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:227pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">than by extending or embedding an existing scripting language or parsing XML,</span><i><span style="font-family:Times,serif;font-size:9.963pt"> yacc</span></i><span style="font-family:Times,serif;font-size:9.963pt"> and</span><i><span style="font-family:Times,serif;font-size:9.963pt"> lex</span></i><span style="font-family:Times,serif;font-size:9.963pt"> will</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:239pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">probably be your most important tools after your C compiler.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:261pt;left:72pt"><i><span style="font-family:Times,serif;font-size:9.963pt">lex</span></i><span style="font-family:Times,serif;font-size:9.963pt"> and</span><i><span style="font-family:Times,serif;font-size:9.963pt"> yacc</span></i><span style="font-family:Times,serif;font-size:9.963pt"> each generate code for a single function &#x2014; respectively, &#x201c;get a token from the input</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:273pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">stream&#x201d; and &#x201c;parse a sequence of tokens to see if it matches a grammar&#x201d;.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:273pt;left:393pt"><span style="font-family:Times,serif;font-size:9.963pt">Usually, the</span><i><span style="font-family:Times,serif;font-size:9.963pt"> yacc</span></i><span style="font-family:Times,serif;font-size:9.963pt">-</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:285pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">generated parser function calls a Lex-generated tokenizer function each time it wants to get another</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:297pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">token.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:297pt;left:108pt"><span style="font-family:Times,serif;font-size:9.963pt">If there are no user-written C callbacks at all in the</span><i><span style="font-family:Times,serif;font-size:9.963pt"> yacc</span></i><span style="font-family:Times,serif;font-size:9.963pt">-generated parser, all it will do</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:309pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">is a syntax check; the value returned will tell the caller if the input matched the grammar it was</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:321pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">expecting.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:343pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">More usually, the user&#x2019;s C code, embedded in the generated parser, populates some runtime data</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:355pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">structures as a side-effect of parsing the input. If the minilanguage is declarative, your application</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:367pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">can use these runtime data structures directly.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:367pt;left:272pt"><span style="font-family:Times,serif;font-size:9.963pt">If your design was an imperative minilanguage,</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:379pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">the data structures might include a parse tree which is immediately fed to some kind of evaluation</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:391pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">function.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:413pt;left:72pt"><i><span style="font-family:Times,serif;font-size:9.963pt">yacc</span></i><span style="font-family:Times,serif;font-size:9.963pt"> has a rather ugly interface, through exported global variables with the name pre&#xfb01;x</span><tt><span style="font-family:Courier,monospace;font-size:8.966pt"> yy_</span></tt><span style="font-family:Times,serif;font-size:9.963pt">. This is</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:425pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">because it predates structs in C; in fact,</span><i><span style="font-family:Times,serif;font-size:9.963pt"> yacc</span></i><span style="font-family:Times,serif;font-size:9.963pt"> predates C itself; the &#xfb01;rst implementation was written</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:437pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">in C&#x2019;s predecessor B. The crude though effective algorithm</span><i><span style="font-family:Times,serif;font-size:9.963pt"> yacc</span></i><span style="font-family:Times,serif;font-size:9.963pt">-generated parsers use to try to</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:448pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">recover from parse errors (pop tokens until an explicit error production is matched) can also lead to</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:460pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">problems, including memory leaks.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:482pt;left:108pt"><span style="font-family:Times,serif;font-size:9.963pt">If you are building parse trees, using malloc to make nodes, and you start popping</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:494pt;left:108pt"><span style="font-family:Times,serif;font-size:9.963pt">things off the stack in error recovery, you don&#x2019;t get to recover (free) the storage.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:506pt;left:108pt"><span style="font-family:Times,serif;font-size:9.963pt">In general, Yacc can&#x2019;t do it, since it doesn&#x2019;t know enough about what&#x2019;s on the</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:518pt;left:108pt"><span style="font-family:Times,serif;font-size:9.963pt">stack.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:518pt;left:144pt"><span style="font-family:Times,serif;font-size:9.963pt">If the yacc parser were in C++, it could assume that the values were</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:530pt;left:108pt"><span style="font-family:Times,serif;font-size:9.963pt">classes and &#x201c;destruct&#x201d; them. In &#x201c;real&#x201d; compilers, parse tree nodes are generated</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:581pt;left:262pt"><span style="font-family:Times,serif;font-size:9.963pt">392</span></p>
</div>
