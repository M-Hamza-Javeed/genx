<div id="page0" style="position:relative;width:540pt;height:648pt;background-color:white">
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:32pt;left:225pt"><span style="font-family:Times,serif;font-size:9.963pt">Chapter 4. Modularity</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:100pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">small module grain sizes, the increasing complexity of the interfaces becomes the dominating term;</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:112pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">it&#x2019;s dif&#xfb01;cult to read the code because you have to understand everything before you can understand</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:124pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">anything.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:124pt;left:119pt"><span style="font-family:Times,serif;font-size:9.963pt">In Chapter 7 we&#x2019;ll examine more advanced forms of program partitioning; there, too,</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:136pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">the complexity of interface protocols comes to dominate the total complexity of the system as the</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:148pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">component processes get smaller.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:170pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">In nonmathematical terms, Hatton&#x2019;s empirical results imply a sweet spot between 200 and 400</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:181pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">logical lines of code that minimizes probable defect density, all other factors (such as programmer</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:193pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">skill) being equal.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:193pt;left:155pt"><span style="font-family:Times,serif;font-size:9.963pt">This size is independent of the language being used &#x2014; an observation which</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:205pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">strongly reinforces the advice given elsewhere in this book to program with the most powerful</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:217pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">languages and tools you can.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:217pt;left:196pt"><span style="font-family:Times,serif;font-size:9.963pt">Beware of taking these numbers too literally however. Methods for</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:229pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">counting lines of code vary considerably according to what the analyst considers a logical line, and</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:241pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">other biases (such as whether comments are stripped). Hatton himself suggests as a rule of thumb a</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:253pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">2x conversion between logical and physical lines, suggesting an optimal range of 400&#x2013;800 physical</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:265pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">lines.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:288pt;left:72pt"><b><span style="font-family:Helvetica,sans-serif;font-size:15.94pt">Compactness and Orthogonality</span></b></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:316pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Code is not the only sort of thing with an optimal chunk size. Languages and APIs (such as sets of</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:328pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">library or system calls) run up against the same sorts of human cognitive constraints that produce</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:340pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Hatton&#x2019;s U-curve.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:362pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Accordingly, Unix programmers have learned to think very hard about two other properties when</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:374pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">designing APIs, command sets, protocols, and other ways to make computers do tricks:</span><i><span style="font-family:Times,serif;font-size:9.963pt"> compactness</span></i></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:386pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">and</span><i><span style="font-family:Times,serif;font-size:9.963pt"> orthogonality</span></i><span style="font-family:Times,serif;font-size:9.963pt">.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:408pt;left:72pt"><b><span style="font-family:Helvetica,sans-serif;font-size:13.948pt">Compactness</span></b></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:435pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Compactness is the property that a design can &#xfb01;t inside a human being&#x2019;s head. A good practical test</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:446pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">for compactness is this: Does an experienced user normally need a manual? If not, then the design</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:458pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">(or at least the subset of it that covers normal use) is compact.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:480pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Compact software tools have all the virtues of physical tools that &#xfb01;t well in the hand.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:480pt;left:429pt"><span style="font-family:Times,serif;font-size:9.963pt">They feel</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:492pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">pleasant to use, they don&#x2019;t obtrude themselves between your mind and your work, they make you</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:504pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">more productive &#x2014; and they are much less likely than unwieldy tools to turn in your hand and injure</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:516pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">you.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:581pt;left:262pt"><span style="font-family:Times,serif;font-size:9.963pt">111</span></p>
</div>
