<div id="page0" style="position:relative;width:540pt;height:648pt;background-color:white">
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:32pt;left:222pt"><span style="font-family:Times,serif;font-size:9.963pt">Chapter 13. Complexity</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:100pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Questions about simplicity, complexity, and the right size of software arouse a lot of passion in the</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:112pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Unix world.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:112pt;left:128pt"><span style="font-family:Times,serif;font-size:9.963pt">Unix programmers have learned a view of the world in which simplicity is beauty is</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:124pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">elegance is good, and in which complexity is ugliness is grotesquery is evil.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:146pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Underlying the Unix programmer&#x2019;s passion for simplicity is a pragmatic fact: complexity costs.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:158pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Complex software is harder to think about, harder to test, harder to debug, and harder to maintain</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:170pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">&#x2014; and above all, harder to learn and use.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:170pt;left:260pt"><span style="font-family:Times,serif;font-size:9.963pt">The costs of complexity, rough as they are during</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:181pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">development, bite hardest after deployment. Complexity creates places for bugs to nest, from which</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:193pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">they will emerge to trouble the world through the entire lifetime of their software.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:215pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">All kinds of pressures tend to drag programmers into a swamp of complexity nevertheless. We&#x2019;ve</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:227pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">examined a rogue&#x2019;s gallery of these in earlier chapters; feature creep and premature optimization are</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:239pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">the two most notorious.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:239pt;left:177pt"><span style="font-family:Times,serif;font-size:9.963pt">Traditionally, Unix programmers push back against these tendencies by</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:251pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">proclaiming with religious fervor a rhetoric that condemns all complexity as bad.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:273pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">So what exactly do we mean by &#x2018;complexity&#x2019;? This point is worth pinning down, because it varies</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:285pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">by observer.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:307pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Unix programmers (like other programmers) tend to focus on</span><i><span style="font-family:Times,serif;font-size:9.963pt"> implementation complexity</span></i><span style="font-family:Times,serif;font-size:9.963pt">&#x2014;basically,</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:319pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">the degree of dif&#xfb01;culty a programmer will experience in attempting to understand a program so he</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:331pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">or she can mentally model or debug it.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:353pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Customers and users, on the other hand, tend to see complexity in terms of the program&#x2019;s</span><i><span style="font-family:Times,serif;font-size:9.963pt"> interface</span></i></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:365pt;left:72pt"><i><span style="font-family:Times,serif;font-size:9.963pt">complexity</span></i><span style="font-family:Times,serif;font-size:9.963pt">. In Chapter 11 we discussed the quality of ease and its inverse, mnemonic load.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:365pt;left:457pt"><span style="font-family:Times,serif;font-size:9.963pt">To</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:377pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">a user, complexity correlates closely with mnemonic load.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:377pt;left:326pt"><span style="font-family:Times,serif;font-size:9.963pt">Poor expressiveness and concision</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:389pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">can matter too, if a weak interface forces the user to perform lots of error-prone or merely tedious</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:401pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">low-level operations rather than a few high-level ones.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:423pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Driven by both of these is a third measure that is much simpler: the total number of lines of code in</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:435pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">the system, its</span><i><span style="font-family:Times,serif;font-size:9.963pt"> codebase size</span></i><span style="font-family:Times,serif;font-size:9.963pt">. In terms of life-cycle costs, this is usually the most important measure.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:446pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">The reasons go back to perhaps the most important empirical result in software engineering, one</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:458pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">we&#x2019;ve cited before: the defect density of code, bugs per hundred lines, tends to be a constant</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:470pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">independent of implementation language. More lines of code means more bugs, and debugging</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:482pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">is the most expensive and time-consuming part of development.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:504pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Codebase size, interface complexity and implementation complexity may all rise together.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:504pt;left:449pt"><span style="font-family:Times,serif;font-size:9.963pt">That</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:516pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">is the usual result of feature creep, and why programmers especially dread it.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:516pt;left:427pt"><span style="font-family:Times,serif;font-size:9.963pt">Premature</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:528pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">optimization doesn&#x2019;t tend to raise interface complexity, but it has bad effects (often severely bad)</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:581pt;left:262pt"><span style="font-family:Times,serif;font-size:9.963pt">336</span></p>
</div>
