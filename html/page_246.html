<div id="page0" style="position:relative;width:540pt;height:648pt;background-color:white">
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:32pt;left:218pt"><span style="font-family:Times,serif;font-size:9.963pt">Chapter 8. Minilanguages</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:100pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">C program by sending commands to an instance of the interpreter and receiving the results back as</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:112pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">values in C.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:134pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Both techniques also rely on the ability to move data between the type ontology of C and the type</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:146pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">ontology of your scripting language. Some scripting languages are designed from the ground up to</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:158pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">support this. One such is Tcl, which we&#x2019;ll cover in Chapter 14. Another is</span><i><span style="font-family:Times,serif;font-size:9.963pt"> Guile</span></i><span style="font-family:Times,serif;font-size:9.963pt">, an open-source</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:170pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">dialect of the Lisp variant Scheme.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:170pt;left:224pt"><i><span style="font-family:Times,serif;font-size:9.963pt">Guile</span></i><span style="font-family:Times,serif;font-size:9.963pt"> is shipped as a library and speci&#xfb01;cally designed to be</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:181pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">embedded in C programs.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:203pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">It is possible (though in 2003 still rather painful and dif&#xfb01;cult) to extend or embed Perl.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:203pt;left:431pt"><span style="font-family:Times,serif;font-size:9.963pt">It is very</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:215pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">easy to extend Python and only slightly more dif&#xfb01;cult to embed it; C extension is especially heavily</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:227pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">used in the Python world. Java has an interface to call &#x2018;native methods&#x2019; in C, though the practice is</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:239pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">explicitly discouraged because it tends to break portability. Most versions of shell are not designed</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:251pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">for embeddability and extension, but the Korn shell (ksh93 and later versions) is a notable exception.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:273pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">There are lots of bad reasons not to piggyback your imperative minilanguage on an existing scripting</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:285pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">language. One of the few good ones is that you actually want to implement your own custom</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:297pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">grammar for error checking. If that&#x2019;s the case, then see the advice about</span><i><span style="font-family:Times,serif;font-size:9.963pt"> yacc</span></i><span style="font-family:Times,serif;font-size:9.963pt"> and</span><i><span style="font-family:Times,serif;font-size:9.963pt"> lex</span></i><span style="font-family:Times,serif;font-size:9.963pt"> below.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:319pt;left:72pt"><b><span style="font-family:Helvetica,sans-serif;font-size:13.948pt">Writing a Custom Grammar</span></b></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:346pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">For declarative minilanguages, one major question is whether or not you should use XML as a base</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:358pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">syntax and specify your grammar as an XML document type. This may well be the right thing for</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:370pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">elaborately structured declarative minilanguages, but the same caveats we noted in Chapter 5 about</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:382pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">the design of data-&#xfb01;le formats apply &#x2014; XML might be overkill.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:382pt;left:345pt"><span style="font-family:Times,serif;font-size:9.963pt">If you don&#x2019;t use XML, follow</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:393pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">the Rule of Least Surprise by supporting the Unix conventions we described for data &#xfb01;les (simple</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:405pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">token-oriented syntax, supporting C backslash conventions, etc.).</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:427pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">If you do need a custom grammar,</span><i><span style="font-family:Times,serif;font-size:9.963pt"> yacc</span></i><span style="font-family:Times,serif;font-size:9.963pt"> and</span><i><span style="font-family:Times,serif;font-size:9.963pt"> lex</span></i><span style="font-family:Times,serif;font-size:9.963pt"> (or their local equivalent in the language you&#x2019;re</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:439pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">using) should probably be your best friends, unless the grammar of your language is so simple that</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:451pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">hand-coding a recursive-descent parser is trivial. Even then,</span><i><span style="font-family:Times,serif;font-size:9.963pt"> yacc</span></i><span style="font-family:Times,serif;font-size:9.963pt"> may give you better error recovery,</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:463pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">and a</span><i><span style="font-family:Times,serif;font-size:9.963pt"> yacc</span></i><span style="font-family:Times,serif;font-size:9.963pt"> speci&#xfb01;cation will be easier to modify as the language syntax evolves. See Chapter 9 for</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:475pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">a look at the</span><i><span style="font-family:Times,serif;font-size:9.963pt"> yacc</span></i><span style="font-family:Times,serif;font-size:9.963pt">- and</span><i><span style="font-family:Times,serif;font-size:9.963pt"> lex</span></i><span style="font-family:Times,serif;font-size:9.963pt">-derived tools available in different implementation languages.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:497pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Even if you decide you must implement your own syntax, consider what mileage you can get from</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:509pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">reusing existing tools.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:509pt;left:172pt"><span style="font-family:Times,serif;font-size:9.963pt">If you need a macro facility, consider whether preprocessing with m4(1)</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:521pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">might be the right answer &#x2014; but consider the cautions in the next section &#xfb01;rst.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:581pt;left:262pt"><span style="font-family:Times,serif;font-size:9.963pt">245</span></p>
</div>
