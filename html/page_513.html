<div id="page0" style="position:relative;width:540pt;height:648pt;background-color:white">
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:32pt;left:230pt"><span style="font-family:Times,serif;font-size:9.963pt">Chapter 20. Futures</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:100pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">say that protecting the user from himself should be done at the GUI or application level, not in the</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:112pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">operating system.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:134pt;left:72pt"><b><span style="font-family:Helvetica,sans-serif;font-size:13.948pt">Unix Assumes a Static File System</span></b></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:160pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Unix has, in one sense, a very static model of the world. Programs are implicitly assumed to run</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:172pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">only brie&#xfb02;y, so the background of &#xfb01;les and directories can be assumed static during their execution.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:184pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">There is no standard, well-established way to ask the system to notify an application if and when</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:196pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">a speci&#xfb01;ed &#xfb01;le or directory changes.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:196pt;left:233pt"><span style="font-family:Times,serif;font-size:9.963pt">This becomes a signi&#xfb01;cant issue when writing long-lived</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:208pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">user-interface software which wants to know about changes to the background.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:226pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Linux has &#xfb01;le- and directory-change noti&#xfb01;cation features,</span><sup><span style="font-family:Times,serif;font-size:6.273pt">156</span></sup><sup><span style="font-family:Times,serif;font-size:9.963pt"> </span></sup><span style="font-family:Times,serif;font-size:9.963pt">and some versions of BSD have copied</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:242pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">them, but these are not yet portable to other Unixes.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:264pt;left:72pt"><b><span style="font-family:Helvetica,sans-serif;font-size:13.948pt">The Design of Job Control Was Badly Botched</span></b></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:291pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Apart from the ability to suspend processes (in itself a trivial addition to the scheduler which could be</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:303pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">made fairly inoffensive) what job control is about is switching a terminal among multiple processes.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:315pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Unfortunately, it does the easiest part &#x2014; deciding where keystrokes go &#x2014; and punts all the hard</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:327pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">parts, like saving and restoring the state of the screen, to the application.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:348pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">A really good implementation of such a facility would be completely invisible to user processes:</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:360pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">no dedicated signals, no need to save and restore terminal modes, no need for the applications to</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:372pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">redraw the screen at random times.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:372pt;left:224pt"><span style="font-family:Times,serif;font-size:9.963pt">The model ought to be a virtual keyboard that is sometimes</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:384pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">connected to the real one (and blocks you if you ask for input when it isn&#x2019;t connected) and a virtual</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:396pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">screen which is sometimes visible on the real one (and might or might not block on output when it&#x2019;s</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:408pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">not), with the system doing the multiplexing in the same way it multiplexes access to the disk, the</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:420pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">processor, etc... and no impact on user programs at all.</span><sup><span style="font-family:Times,serif;font-size:6.273pt">157</span></sup></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:442pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Doing it right would have required the Unix tty driver to track the entire current screen state rather</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:454pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">than just maintaining a line buffer, and to know about terminal types at kernel level (possibly</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:466pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">with help from a daemon process) so it could do restores properly when a suspended process is</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:478pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">foregrounded again.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:478pt;left:168pt"><span style="font-family:Times,serif;font-size:9.963pt">A consequence of doing it wrong is that the Unix kernel can&#x2019;t detach a</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:498pt;left:72pt"><span style="font-family:Times,serif;font-size:5.018pt">156</span><span style="font-family:Times,serif;font-size:7.97pt">Look for</span><tt><span style="font-family:Courier,monospace;font-size:7.173pt"> F_NOTIFY</span></tt><span style="font-family:Times,serif;font-size:7.97pt"> under fcntl(2).</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:503pt;left:72pt"><span style="font-family:Times,serif;font-size:5.018pt">157</span><span style="font-family:Times,serif;font-size:7.97pt"> This paragraph is based on a 1984 analysis by Henry Spencer. He went on to note that job control was necessary and</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:516pt;left:72pt"><span style="font-family:Times,serif;font-size:7.97pt">appropriate for POSIX.1 and later Unix standards to consider precisely</span><i><span style="font-family:Times,serif;font-size:7.97pt"> because</span></i><span style="font-family:Times,serif;font-size:7.97pt"> it oozes its way into every program, and</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:526pt;left:72pt"><span style="font-family:Times,serif;font-size:7.97pt">hence has to be thought about in any application-to-system interface. Hence, POSIX&#x2019;s endorsement of a mis-design, while</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:535pt;left:72pt"><span style="font-family:Times,serif;font-size:7.97pt">proper solutions were &#x201c;out of scope&#x201d; and hence were not even considered.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:581pt;left:262pt"><span style="font-family:Times,serif;font-size:9.963pt">512</span></p>
</div>
