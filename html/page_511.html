<div id="page0" style="position:relative;width:540pt;height:648pt;background-color:white">
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:32pt;left:230pt"><span style="font-family:Times,serif;font-size:9.963pt">Chapter 20. Futures</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:100pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Fans of the Macintosh family of operating systems tend to be vociferous about this.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:100pt;left:447pt"><span style="font-family:Times,serif;font-size:9.963pt">They</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:112pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">advocate a model in which a single &#xfb01;lename may have both data and resource &#x2018;forks&#x2019;, the data</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:124pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">fork corresponding to the Unix byte stream and the resource fork being a collection of name/value</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:136pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">pairs. Unix partisans prefer approaches that make &#xfb01;le data self-describing so that effectively the</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:148pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">same sort of metadata is stored within the &#xfb01;le.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:170pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">The problem with the Unix approach is that every program that writes the &#xfb01;le has to know about it.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:181pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Thus, for example, if we want the &#xfb01;le to carry type information inside it, every tool that touches it</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:193pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">has to take care to either preserve the type &#xfb01;eld unaltered or interpret and then rewrite it. While this</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:205pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">would be theoretically possible to arrange, in practice it would be far too fragile.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:227pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">On the other hand, supporting &#xfb01;le attributes raises awkward questions about which &#xfb01;le operations</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:239pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">should preserve them. It&#x2019;s clear that a copy of a named &#xfb01;le to another name should copy the source</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:251pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">&#xfb01;le&#x2019;s attributes as well as its data &#x2014; but suppose we cat(1) the &#xfb01;le, redirecting the output of cat(1)</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:263pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">to a new name?</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:285pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">The answer to this question depends on whether the attributes are actually properties of &#xfb01;lenames</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:297pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">or are in some magical way bundled with the &#xfb01;le&#x2019;s data as a sort of invisible preamble or postamble.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:309pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Then the question becomes: Which operations make the properties visible?</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:331pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Xerox PARC &#xfb01;le-system designs grappled with this problem as far back as the 1970s. They had an</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:343pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">&#x2018;open serialized&#x2019; call that returned a byte stream containing both attributes and content. If applied</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:355pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">to a directory, it returned a serialization of the directory&#x2019;s attributes plus the serialization of all the</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:367pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">&#xfb01;les in it. It is not clear that this approach has ever been bettered.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:389pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">Linux 2.5 already supports attaching arbitrary name/value pairs as properties of a &#xfb01;lename, but at</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:401pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">time of writing this capability is not yet much used by applications. Recent versions of Solaris have</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:413pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">a roughly equivalent feature.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:435pt;left:72pt"><b><span style="font-family:Helvetica,sans-serif;font-size:13.948pt">Unix Support for GUIs Is Weak</span></b></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:461pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">The Unix experience proves that using a handful of metaphors as the basis for a framework is a</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:473pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">powerful strategy (recall the discussion of frameworks and shared context in Chapter 13).</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:473pt;left:452pt"><span style="font-family:Times,serif;font-size:9.963pt">The</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:485pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">visual metaphor at the heart of modern GUIs (&#xfb01;les represented by icons, and opened by clicking</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:497pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">which invokes some designated handler program, typically able to create and edit these &#xfb01;les) has</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:509pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">proven both successful and long-lived, exerting a strong hold on users and interface designers ever</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:521pt;left:72pt"><span style="font-family:Times,serif;font-size:9.963pt">since Xerox PARC pioneered it in the 1970s.</span></p>
<p style="position:absolute;white-space:pre;margin:0;padding:0;top:581pt;left:262pt"><span style="font-family:Times,serif;font-size:9.963pt">510</span></p>
</div>
